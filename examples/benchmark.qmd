---
title: "WENDy Preview"
author: "Jack Krebsbach"
execute:
  cache: true
format: 
    revealjs:
        theme: solarized 
        controls: true           
        progress: true           
        slide-number: true 
---

```{r, setup, include=FALSE}
library(wendy)
library(symengine)
library(deSolve)
library(plotly)
set.seed(42)
```

## Logistic  

<span style="font-size:60%">
$$
\dot{u}=p_1 u + p_2 u^2
$$
</span>

```{r, fig.align='center'}
logistic <- function(u, p, t) {
  list(p[[1]] * u[[1]] - p[[2]] * u[[1]]^2)
}

noise_sd <- 0.05
p_star <- c(1, 1)
u0 <- c(0.01)
p0 <- c(0.5, 0.5)
npoints <- 100
t_span <- c(0, 10)
t_eval <- seq(t_span[1], t_span[2], length.out = npoints)

modelODE <- function(tvec, state, parameters) {
  list(as.vector(logistic(state, parameters, tvec)))
}

sol <- deSolve::ode(y = u0, times = t_eval, func = modelODE, parms = p_star)
# Additive Guassian
noise <- rnorm(npoints, mean = 0, sd = noise_sd)
U <- matrix(c(sol[, 2] + noise), ncol = 1)
# Log Normal
# noisy <- sol[, 2] * exp(noise)
# U <- matrix(noisy, ncol = 1)

tt <- matrix(sol[, 1], ncol = 1)

res <- WendySolver(
  logistic,
  U,
  p0,
  tt,
  noise_sd,
  compute_svd_ = TRUE,
  optimize_ = TRUE,
  dist_type = "AddGaussian"
)

p_hat <- res$p_hat

sol_hat <- deSolve::ode(u0, t_eval, modelODE, p_hat)

par(bg = NA)
plot(sol[, 2], type = "l", lwd = 2, col = rgb(0.2, 0.4, 1, 0.7))
lines(sol_hat[, 2], lwd = 2, col = rgb(1, 0.2, 0.2, 0.7))
points(U[, 1], cex = 0.4, col = rgb(0.5, 0.5, 0.5, 0.95))

```


```{r, fig.align='center'}
cat("npoints:", paste(npoints, collapse = " "), "\n")
cat("pstar:", paste(p_star, collapse = " "), "\n")
cat(
  "phat:",
  paste(format(p_hat, digits = 3, scientific = FALSE), collapse = " "),
  "\n"
)
rel_error <- abs(p_hat - p_star) / abs(p_star)

cat(
  "Relative coefficient error:",
  paste(format(rel_error, digits = 1), collapse = " "),
  "\n"
)
```

## Lorenz  

<span style="font-size:60%">
$$
\begin{aligned}
& \dot{u}_1=p_1\left(u_2-u_1\right) \\
& \dot{u}_2=u_1\left(p_2-u_3\right)-u_2 \\
& \dot{u}_3=u_1 u_2-p_3 u_3
\end{aligned}
$$
</span>

```{r, fig.align='center'}
lorenz <- function(u, p, t) {
  du1 <- p[[1]] * (u[[2]] - u[[1]])
  du2 <- u[[1]] * (p[[2]] - u[[3]]) - u[[2]]
  du3 <- u[[1]] * u[[2]] - p[[3]] * u[[3]]
  list(du1, du2, du3)
}

noise_sd <- 0.05
p_star <- c(10.0, 28.0, 4.0)
p0 <- c(13.10, 21, 4.0)
u0 <- c(2, 1, 1)
npoints <- 200
t_span <- c(0, 10)
t_eval <- seq(t_span[1], t_span[2], length.out = npoints)

modelODE <- function(tvec, state, parameters) {
  list(as.vector(lorenz(state, parameters, tvec)))
}

sol <- deSolve::ode(y = u0, times = t_eval, func = modelODE, parms = p_star)
# Additive Guassian
noise <- rnorm(npoints, mean = 0, sd = noise_sd)
U <- sol[, -1] + noise
# Log Normal
# noisy <- sol[, 2] * exp(noise)
# U <- matrix(noisy, ncol = 1)

tt <- matrix(sol[, 1], ncol = 1)

res <- WendySolver(
  lorenz,
  U,
  p0,
  tt,
  noise_sd,
  compute_svd_ = TRUE,
  optimize_ = TRUE,
  dist_type = "AddGaussian"
)

p_hat <- res$p_hat

sol_hat <- deSolve::ode(u0, t_eval, modelODE, p_hat)

par(bg = NA)
plot(sol[, -1][, c(1, 2)], type = "l", lwd = 2, col = rgb(0.2, 0.4, 1, 0.7))
lines(sol_hat[, -1][, c(1, 2)], lwd = 2, col = rgb(1, 0.2, 0.2, 0.7))
points(U[, c(1, 2)], cex = 0.4, col = rgb(0.5, 0.5, 0.5, 0.95))

```


```{r}
cat("npoints:", paste(npoints, collapse = " "), "\n")
cat("pstar:", paste(p_star, collapse = " "), "\n")
cat(
  "phat:",
  paste(format(p_hat, digits = 3, scientific = FALSE), collapse = " "),
  "\n"
)
rel_error <- abs(p_hat - p_star) / abs(p_star)

cat(
  "Relative coefficient error:",
  paste(format(rel_error, digits = 1), collapse = " "),
  "\n"
)
```

## Goodwin 3D
<!-- 
<div style="font-size:0.15em; text-align:center;">
$$
\dot{u}_1 = \frac{p_1}{2.15 + p_3 u_3^{p_4}} - p_2 u_1
\quad
\dot{u}_2 = p_5 u_1 - p_6 u_2
\quad
\dot{u}_3 = p_7 u_2 - p_8 u_3
$$

</div> -->

```{r, fig.align='center', cache=TRUE}
goodwin <- function(u, p, t) {
  du1 <- p[[1]] / (2.15 + p[[3]] * u[[3]]^p[[4]]) - p[[2]] * u[[1]]
  du2 <- p[[5]] * u[[1]] - p[[6]] * u[[2]]
  du3 <- p[[7]] * u[[2]] - p[[8]] * u[[3]]
  list(du1, du2, du3)
}

noise_sd <- 0.01
npoints <- 100
p_star <- c(3.4884, 0.0969, 1, 10, 0.0969, 0.0581, 0.0969, 0.0775)
p0 <- c(3, 0.1, 4, 12, 0.1, 0.1, 0.1, 0.1)
u0 <- c(0.3617, 0.9137, 1.393)
t_span <- c(0, 80)

modelODE <- function(tvec, state, parameters) {
  list(as.vector(goodwin(state, parameters, tvec)))
}

t_eval <- seq(t_span[1], t_span[2], length.out = npoints)
sol <- deSolve::ode(
  y = u0,
  times = t_eval,
  func = modelODE,
  parms = p_star,
  method = "lsodes",
  atol = 1e-10,
  rtol = 1e-10
)

noise <- matrix(
  rnorm(nrow(sol) * (ncol(sol) - 1), mean = 0, sd = noise_sd),
  nrow = nrow(sol)
)
U <- sol[, -1] * exp(noise)
tt <- matrix(sol[, 1], ncol = 1)

p <- WendySolver(
  goodwin,
  U,
  p0,
  tt,
  noise_sd,
  compute_svd_ = TRUE,
  optimize_ = TRUE,
  dist_type_ = "LogNormal"
)

p_hat <- p$p_hat

U_hat <- deSolve::ode(
  y = u0,
  times = t_eval,
  func = modelODE,
  parms = p_hat,
  method = "lsodes",
  atol = 1e-10,
  rtol = 1e-10
)[, -1]

# plot(sol[, -1][, c(1, 3)], cex = 0.5)
# points(u_hat[, c(1, 3)], cex = 0.5, col = "red")

fig3d <- plot_ly() |>
  add_trace(
    x = sol[, -1][, 1],
    y = sol[, -1][, 2],
    z = sol[, -1][, 3],
    type = 'scatter3d',
    mode = 'lines',
    name = 'True Trajectory'
  ) |>
  add_trace(
    x = U_hat[, 1],
    y = U_hat[, 2],
    z = U_hat[, 3],
    type = 'scatter3d',
    mode = 'lines',
    name = 'Estimated Trajectory',
    line = list(color = 'red', opacity = 0.95)
  ) |>
  add_trace(
    x = U[, 1],
    y = U[, 2],
    z = U[, 3],
    type = 'scatter3d',
    mode = 'markers',
    name = 'Noisty Data',
    marker = list(color = 'black', size = 2, opacity = 0.35)
  ) |>
  layout(
    paper_bgcolor = 'rgba(0,0,0,0)', # Transparent outer background
    plot_bgcolor = 'rgba(0,0,0,0)', # Transparent plot area
    legend = list(
      x = 0.02,
      y = 0.98,
      xanchor = "left",
      yanchor = "top"
    )
  )

fig3d
```

```{r}
cat("npoints:", paste(npoints, collapse = " "), "\n")
cat("pstar:", paste(p_star, collapse = " "), "\n")
cat(
  "phat:",
  paste(format(p_hat, digits = 3, scientific = FALSE), collapse = " "),
  "\n"
)
rel_error <- abs(p_hat - p_star) / abs(p_star)

cat(
  "Relative coefficient error:",
  paste(format(rel_error, digits = 1), collapse = " "),
  "\n"
)
```

## Comparison to Gaussian Processes (magi)
