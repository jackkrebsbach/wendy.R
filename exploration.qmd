---
Title: Wendy Exploration MLE
author: Jack Krebsbach
format:
 typst:
    toc: true
    section-numbering: 1.1.a
---

# Wendy

Load libraries

```{r}
library(reticulate)
```


## Test functions

```{python}
import numpy as np
import matplotlib.pyplot as plt
from scipy.integrate import quad
from scipy.integrate import solve_ivp


# Test function: This is centered at 0
def phi(t, r=2, c=0):
    return np.exp(
        -9 / np.maximum((1 - ((t - c) / r) ** 2), 1e-10)
    )  # We use 1e-10 instead of 0, otherwise we divide by 0


def phi_normed(t):
    C = quad(lambda t: phi(t), a=0, b=1)
    return phi(t) / C


t = np.arange(-1, 1, 0.01)

plt.clf()
plt.plot(t, phi(t, r=1))
```

What about a different centering?
```{python}
t = np.arange(-1, 3, 0.01)
plt.plot(t, phi(t, r=3, c=1))
```

Let us generate some data so we can explore optimizing the test function radius so that the integral error does not dominate the noise. We will look at the goodwind system in 2-Dimensions.
```{python}
def goodwin_2d(t, u, p):
    """
    Goodwin 2D oscillator system
    u1' = p1 - p3/(36 + p2*u2)
    u2' = p4*u1 - p5
    """
    u1, u2 = u
    p1, p2, p3, p4, p5 = p

    du1dt = p1 - p3 / (36 + p2 * u2)
    du2dt = p4 * u1 - p5

    return [du1dt, du2dt]


npoints = 100
t_span = [0, 20]
t_eval = np.linspace(t_span[0], t_span[1], npoints)
u0 = [7, -10]
p_star = [72, 1, 2, 1, 1]

sol = solve_ivp(
    goodwin_2d,
    t_span,
    u0,
    args=(p_star,),
    dense_output=True,
    rtol=1e-8,
    atol=1e-10,
    t_eval=t_eval,
)
```

Plot the data and add some noise
```{python}
t = sol.t
u1_star = sol.y[0]
u2_star = sol.y[1]

# Generate some noise proportional to the data
noise_ratio = 0.05
mean = np.array([0.0, 0.0])
cov = np.diag([noise_ratio * np.var(u1_star), noise_ratio * np.var(u2_star)])
noise = np.random.multivariate_normal(mean, cov, size=npoints)

e1 = [x[0] for x in noise]
e2 = [x[1] for x in noise]

u1 = u1_star + e1
u2 = u2_star + e2


plt.clf()
plt.title("Noisy Data from Goodwin System")
plt.plot(t, u1, marker="o", linestyle="None", markerfacecolor="none", label="u1")
plt.plot(t, u2, marker="o", linestyle="None", markerfacecolor="none", label="u2")
plt.legend()
```


Now lets look at the system in R and see how we can build a symbolic representation in SymEngine


```{r}
p <- c(72, 1, 2, 1, 1)

U <- matrix(c(py$u1, py$u2), ncol = 2)

goodwin_2d <- function(du, u, p, t) {
  #   ""
  #     u1' = p1 - p3/(36 + p2*u2)
  #     u2' = p4*u1 - p5
  #   ""
  u1 <- u[1]
  u2 <- u[2]
  du[1] <- p[1] - p[3] / (36 + p[2] * u2)
  du[2] <- p[4] * u1 - p[5]

  return(du)
}
```

Look at using Rcpp code to pass in functions

```{r}
library(Rcpp)
Rcpp::sourceCpp('./exploration.cpp')

test <- makeSymbolicSystem(U, goodwin_2d, p)
test
```


Finding out it is very hard to pass in an R function so we will build the function in in SymEngine.R

```{r}

```