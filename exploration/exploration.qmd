---
Title: Wendy Exploration MLE
author: Jack Krebsbach
format:
 typst:
    toc: true
    section-numbering: 1.1.a
---

# Wendy

Load libraries

```{r}
library(reticulate)
library(Rcpp)
library(symengine)
```


## System of ODE exploration

Let us generate some data so we can explore optimizing the test function radius so that the integral error does not dominate the noise. We will look at the goodwind system in 2-Dimensions.
```{python}
import numpy as np
from scipy.integrate import solve_ivp
import matplotlib.pyplot as plt

def goodwin_3d(t, u, p):
    """
    Goodwin 3D oscillator system
    u1' = p1 / (2.15 + p3 * u3^p4) - p2 * u1
    u2' = p5 * u1 - p6 * u2
    u3' = p7 * u2 - p8 * u3
    """
    u1, u2, u3 = u
    p1, p2, p3, p4, p5, p6, p7, p8 = p

    du1dt = p1 / (2.15 + p3 * u3**p4) - p2 * u1
    du2dt = p5 * u1 - p6 * u2
    du3dt = p7 * u2 - p8 * u3

    return [du1dt, du2dt, du3dt]

npoints = 100
t_span = [0, 20]
t_eval = np.linspace(t_span[0], t_span[1], npoints)
u0 = [7, -10, 5]  # Initial conditions for u1, u2, u3
p_star = [72, 1, 2, 1, 1, 1, 1, 1]  # 8 parameters

sol = solve_ivp(
    goodwin_3d,
    t_span,
    u0,
    args=(p_star,),
    dense_output=True,
    rtol=1e-8,
    atol=1e-10,
    t_eval=t_eval,
)
t = sol.t
u1_star = sol.y[0]
u2_star = sol.y[1]
u3_star = sol.y[2]

# Generate some noise proportional to the data for all three variables
noise_ratio = 0.05
mean = np.array([0.0, 0.0, 0.0])
cov = np.diag([
    noise_ratio * np.var(u1_star),
    noise_ratio * np.var(u2_star),
    noise_ratio * np.var(u3_star)
])
noise = np.random.multivariate_normal(mean, cov, size=npoints)

e1 = noise[:, 0]
e2 = noise[:, 1]
e3 = noise[:, 2]

u1 = u1_star + e1
u2 = u2_star + e2
u3 = u3_star + e3

plt.figure(figsize=(10, 6))
plt.title("Noisy Data from Goodwin 3D System")
plt.plot(t, u1, marker="o", linestyle="None", markerfacecolor="none", label="u1 (noisy)")
plt.plot(t, u2, marker="o", linestyle="None", markerfacecolor="none", label="u2 (noisy)")
plt.plot(t, u3, marker="o", linestyle="None", markerfacecolor="none", label="u3 (noisy)")
plt.xlabel("Time")
plt.ylabel("Variables")
plt.legend()
plt.grid(True)
plt.tight_layout()
plt.show()

```


## WENDy Module Development

Now lets look at the system in R and see how we can build a symbolic representation in SymEngine.


I explored trying to pass an R function and building it symbolically in cpp, but could not get around it. So looks like we will have to use symengine as a dependency to build the system symbolically in R and then passing it to rcpp.

```{r}
library(Rcpp)
library(symengine)

f <- function(u, p, t) {
  du1 <- p[[1]] / (2.15 + p[[3]] * u[[3]]^p[[4]]) - p[[2]] * u[[1]]
  du2 <- p[[5]] * u[[1]] - p[[6]] * u[[2]]
  du3 <- p[[7]] * u[[2]] - p[[8]] * u[[3]]
  list(du1, du2, du3)
}

p_hat <- as.numeric(py$p_star)
U <- matrix(c(py$u1, py$u2, py$u3), ncol = 3)
tt <- py$t

# Create symbols of system (parameters, state variables, and time )
u <- lapply(1:ncol(U), function(i) S(paste0("u", i)))
p <- lapply(1:length(p_hat), function(i) S(paste0("p", i)))
t <- S("t")

du <- f(u, p, t) |>
  vapply(as.character, character(1))

```

```{r}
unlink(tempdir(), recursive = TRUE)

Sys.setenv("CXX_STD" = "CXX20")
Sys.setenv(DYLD_LIBRARY_PATH = "/opt/homebrew/lib")
Sys.setenv("PKG_CXXFLAGS" = "-std=c++20 -I/opt/homebrew/include")
Sys.setenv("PKG_LIBS" = "-L/opt/homebrew/lib -lsymengine -lflint -lgmp -lmpfr -lfmt")

Rcpp::sourceCpp('exploration/pkg-dev.cpp')

loadModule('WendyR', TRUE)

w <- new(WendyR, du, U, p_hat, matrix(tt, ncol = 1))
w$log_details()
w$build_test_function_matrices()
V_full <- w$getV()
V_full
```


Now try to load the library

```{r}
print(getwd())
library(devtools)
library(terra)

devtools::clean_dll()
devtools::document()
Rcpp::compileAttributes()
devtools::load_all()
```


```{r}
library(WENDyMLE)

w <- new(WENDyMLE::WendyR, du, U, p_hat, matrix(tt, ncol = 1))
w$build_test_function_matrices()
V_full <- w$getV()

```

